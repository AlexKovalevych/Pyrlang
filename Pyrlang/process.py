from __future__ import print_function

import gevent
from gevent import Greenlet
from gevent.queue import Queue


class Process(Greenlet):
    """ Implements Erlang process semantic and lifetime
        Registers itself in the process registry, can receive and send messages
    """
    def __init__(self, node) -> None:
        """ Create a process and register itself. Pid is generated by the node
            object.

            :param node: 
        """
        Greenlet.__init__(self)

        self.inbox_ = Queue()
        """ Message queue (gevent.Queue). Messages are detected by the ``_run``
            loop and handled one by one in ``handle_one_inbox_message()``. 
        """

        self.pid_ = node.register_new_process(self)
        """ Process identifier for this object. Remember that when creating a 
            process, it registers itself in the node, and this creates a
            reference. 
            References prevent an object from being garbage collected.
            To destroy a process, get rid of this extra reference by calling
            ``exit()`` and telling it the cause of its death.
        """

        self.is_exiting_ = False
        self.monitors_ = set()

    def _run(self):
        while not self.is_exiting_:
            while not self.inbox_.empty():
                msg = self.inbox_.get_nowait()
                self.handle_one_inbox_message(msg)
            gevent.sleep(0.0)

    def handle_one_inbox_message(self, msg):
        """ Override this method to handle new incoming messages. """
        print("%s: Handling msg %s" % (self.pid_, msg))

    def exit(self, reason):
        """ Marks the object as exiting with the reason, informs links and
            monitors and unregisters the object from the node process
            dictionary.
        """
        # TODO: Inform links and monitors

        from Pyrlang.node import Node
        Node.singleton.on_exit_process(self.pid_, reason)

